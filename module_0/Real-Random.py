import numpy as np


def game_core_v3(number):
    # Алгоритм использует двоичный поиск приближения к искомому числу:
    # диапазон поиска сужается в два раза на каждом шаге
    # всего надо 7 шагов для прохождения массива из 100: 50, 25, 13, 7, 4, 2, 1
    # (на самом деле 7 шагов нужно для массива до 128, потому что это 2**7)

    steps = [25, 13, 7, 4, 2, 1, 1]                 # устанавливаем шаг приближения к искомому числу
    count = 1                                       # начинаем счет попыток,
    predict = 50                                    # первая попытка угадать

    # далее, пока не угадаем цифру мы увеличиваем предыдущую попытку на половину оставшейся выборки или
    # уменьшаем, в зависимости от того, меньше наша попытка или больше загаданного числа.
    while number != predict:
        predict = predict - steps[count-1] if predict > number else predict + steps[count-1]
        count += 1
    return count  # выход из цикла, если угадали


def score_game(game_core):
    # Запускаем игру 1000 раз, чтобы узнать, как быстро игра угадывает число
    count_ls = []

    # я собрал случайные числа: это последние четыре цифры (взятые попарно) из кодов товаров
    # в чеках из продуктовых магазинов. Сами коды 13-значные, но первые 8 почти наверняка - это
    # код группы/подгруппы товара. А последние 4 выглядят как код непосредственно товара.
    # Считаю, что это достаточно надежный способ собрать действительно слуяайные числа
    # -------------------------------------
    # I collected random numbers: these are the last four digits (taken in pairs) from product codes
    # on receipts from grocery stores. The codes themselves are 13 digits, but the first 8 are almost certainly
    # product group/subgroup code. And the last 4 look like the code of the product itself.
    # I think this is a fairly reliable way to collect really random numbers
    real_random = (60, 44, 58, 87, 31, 38, 17, 6, 19, 26, 81, 8, 95, 32, 67, 96, 30, 6, 61, 49,
                   19, 85, 30, 50, 15, 97, 16, 34, 88, 50, 99, 74, 3, 68, 37, 30, 99, 31, 97, 5,
                   100, 29, 37, 65, 48, 80, 54, 5, 4, 67, 13,
                   23, 50, 59, 21, 27, 38, 59, 21, 2, 67, 53, 58, 68, 28, 34, 8, 1, 78, 3, 90,
                   47, 10, 91, 71, 31, 30, 88, 96, 50, 51, 11, 44, 73, 72)

    for number in real_random:                     # для каждого загаданного числа ...
        count_ls.append(game_core(number))          # собираем количество попыток для отгадки по алгоритму

    score = int(np.mean(count_ls))                  # считаем среднее арифметическое, преобразованное в число
    score_p = np.mean(count_ls)                     # считаем среднее арифметическое
    print("-"*50)
    print(f"Мой алгоритм угадывает число в среднем за {score} попыток")
    print(f"... а если точнее, то за {score_p} попыток\n")
    return score


score_game(game_core_v3)
# с действительно случайными числами вышло 5,64 - лучше, чем с псевдослучайными!
